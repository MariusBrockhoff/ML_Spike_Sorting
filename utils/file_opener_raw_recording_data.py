"""
Module for opening and processing raw recording data from .h5 files.

This module contains a function to open and process raw recording data, particularly from
files generated by Multi Channel Systems (MCS). It handles large files by processing data
in chunks to avoid memory limitations.

Functions:
    file_opener_raw_recording_data(file_name, path, is_big_file=False): Opens a .h5 file
    and extracts recording data, electrode stream, and sampling frequency.
"""
# If you want to use / import Multi channel Systems data, easiest way is to
# import their custom functions to open the standard generated .h5 files:
# MCS PyData tools

import McsPy
import McsPy.McsData
from McsPy import ureg, Q_
import numpy as np

def get_channel_data(data_stream, channel_ids = []):
    """
        Extracts signals from each channel_ids electrodes from MCS .h5 raw recording file

        Args:
            data_stream: data stream containing raw recording
            channel_ids: ids of electrodes to be extracted. If channel_ids = [], extract all

        Returns:
            signal_corrected: AD corrected signal (raw)

        Note:
            - Designed to extract data from .h5 files generated by Multi Channel Systems.
        """
    if channel_ids == []:
        signal = data_stream.channel_data[:, :]
    else:
        index_lst = list()
        for i in channel_ids:
            index_lst.append(data_stream.channel_infos[i].row_index)
        signal = data_stream.channel_data[index_lst, :]
    scale = data_stream.channel_infos[0].adc_step.magnitude
    signal_corrected = (signal - data_stream.channel_infos[0].get_field('ADZero'))  * scale
    return signal_corrected

def file_opener_raw_recording_data(data_preprocessing_config):
    """
        Opens a .h5 file and extracts raw recording data, electrode stream, and sampling frequency.

        This function opens a .h5 file, typically from Multi Channel Systems (MCS), and extracts
        the raw recording data, the electrode stream, and the sampling frequency. It can handle
        large files by reading in the data in segments to avoid RAM limitations.

        Args:
            data_preprocessing_config: Configuration for data preprocessing

        Returns:
            tuple: A tuple containing:
                - recording_data (numpy.ndarray): Array containing the raw recording data.
                                                 Shape = (recorded data points, number of electrodes)
                - electrode_stream (McsPy.McsData.AnalogStream): The original data file containing all raw data and channel infos.
                - fsample (int): Sampling frequency in Hz.

        Note:
            - Requires McsPyDataTools for processing .h5 files generated by Multi Channel Systems.
            - Handles large files by processing in chunks if 'is_big_file' is True.
        """
    path = data_preprocessing_config.DATA_PATH
    big_file = data_preprocessing_config.BIG_FILE
    file = McsPy.McsData.RawData(path)
    electrode_stream = file.recordings[0].analog_streams[0]
    fsample = int(electrode_stream.channel_infos[0].sampling_frequency.magnitude)

    if big_file:
        step_size = 10
        min_step = 0
        max_step = 60
        for i in range(min_step, max_step, step_size):
            scale_factor_for_uV = Q_(1,'volt').to(ureg.uV).magnitude
            if i == min_step:
              recording_data = (get_channel_data(electrode_stream, channel_ids = [j for j in range(i,i+step_size)]) * scale_factor_for_uV).T
            else:
              recording_data = np.concatenate((recording_data, (get_channel_data(electrode_stream, channel_ids = [j for j in range(i,i+step_size)]) * scale_factor_for_uV).T), axis=1)
            print("iteration", i+step_size, "completed")

    else:
        signal = get_channel_data(electrode_stream, channel_ids = [])
        scale_factor_for_uV = Q_(1,'volt').to(ureg.uV).magnitude
        recording_data = signal * scale_factor_for_uV.T

    return recording_data, electrode_stream, fsample
